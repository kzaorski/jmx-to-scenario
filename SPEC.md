# JMX to pt_scenario.yaml Converter - Technical Specification

Version: 1.0
Date: 2024-12-12

---

## 1. Introduction

### 1.1 Purpose

This document specifies a standalone tool to convert JMeter JMX test plan files to `pt_scenario.yaml` format. The tool enables:

- Import existing JMX tests into the pt_scenario ecosystem
- Reverse engineering of JMX files for documentation
- Migration from JMeter GUI-based test development to YAML-based workflow

### 1.2 Scope

The converter supports **any JMX file**, not just those generated by specific tools. It extracts:

- HTTP requests (samplers)
- Variable extraction (JSONPostProcessor)
- Timers (think time)
- Loop controllers
- Thread group settings
- Headers
- Assertions
- User-defined variables

### 1.3 Input/Output

**Input**: JMeter JMX file (XML format)
**Output**: pt_scenario.yaml file (YAML format)

---

## 2. JMX Format Reference

### 2.1 Root Structure

Every JMX file has this root structure:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6">
  <hashTree>
    <!-- Test plan contents -->
  </hashTree>
</jmeterTestPlan>
```

**Root attributes:**
- `version`: JMX format version (typically "1.2")
- `properties`: Properties version
- `jmeter`: JMeter version that created the file

### 2.2 HashTree Hierarchy

The `<hashTree>` element is fundamental to JMX organization. It creates parent-child relationships.

**Pattern:**
```xml
<Element1>
  <!-- Element properties -->
</Element1>
<hashTree>
  <!-- Children of Element1 -->
  <Element2>...</Element2>
  <hashTree>
    <!-- Children of Element2 -->
  </hashTree>
</hashTree>
```

**Key rules:**
1. Every test element is followed by a `<hashTree>` containing its children
2. Leaf elements have an empty `<hashTree/>`
3. The structure is both hierarchical and ordered (sequence matters)

**Hierarchy example:**
```
jmeterTestPlan
  hashTree
    TestPlan
    hashTree
      ConfigTestElement (HTTP Defaults)
      hashTree/
      Arguments (User Variables)
      hashTree/
      ThreadGroup
      hashTree
        HTTPSamplerProxy
        hashTree
          JSONPostProcessor
          hashTree/
          ResponseAssertion
          hashTree/
```

### 2.3 Common Element Attributes

All test elements share common attributes:

```xml
<ElementName
  guiclass="GUIClassName"
  testclass="TestClassName"
  testname="Display Name"
  enabled="true">
  <!-- Properties -->
</ElementName>
```

| Attribute | Description |
|-----------|-------------|
| `guiclass` | GUI class for JMeter UI |
| `testclass` | Test element class name |
| `testname` | Display name in JMeter |
| `enabled` | "true" or "false" |

### 2.4 Property Types

JMX uses multiple property element types:

#### stringProp
```xml
<stringProp name="HTTPSampler.domain">localhost</stringProp>
<stringProp name="HTTPSampler.port">8080</stringProp>
<stringProp name="HTTPSampler.method">POST</stringProp>
```

#### boolProp
```xml
<boolProp name="HTTPSampler.follow_redirects">true</boolProp>
<boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
```

#### intProp
```xml
<intProp name="Assertion.test_type">8</intProp>
```

#### elementProp
Complex nested properties:
```xml
<elementProp name="HTTPsampler.Arguments" elementType="Arguments">
  <collectionProp name="Arguments.arguments">
    <!-- Items -->
  </collectionProp>
</elementProp>
```

#### collectionProp
Arrays/lists of properties:
```xml
<collectionProp name="Arguments.arguments">
  <elementProp name="param1" elementType="HTTPArgument">
    <stringProp name="Argument.name">param1</stringProp>
    <stringProp name="Argument.value">value1</stringProp>
  </elementProp>
</collectionProp>
```

### 2.5 TestPlan Element

Root test configuration:

```xml
<TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="My Test Plan" enabled="true">
  <boolProp name="TestPlan.functional_mode">false</boolProp>
  <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
  <elementProp name="TestPlan.user_defined_variables" elementType="Arguments">
    <collectionProp name="Arguments.arguments"/>
  </elementProp>
</TestPlan>
```

**Properties to extract:**
- `testname` attribute -> scenario `name`
- `TestPlan.user_defined_variables` -> scenario `variables`

### 2.6 ConfigTestElement (HTTP Request Defaults)

Centralizes server configuration:

```xml
<ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
  <stringProp name="HTTPSampler.domain">petstore.swagger.io</stringProp>
  <stringProp name="HTTPSampler.port">443</stringProp>
  <stringProp name="HTTPSampler.protocol">https</stringProp>
  <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
</ConfigTestElement>
```

**Properties to extract:**
| Property | Description |
|----------|-------------|
| `HTTPSampler.domain` | Server hostname |
| `HTTPSampler.port` | Port number (empty = default) |
| `HTTPSampler.protocol` | "http" or "https" |

**Base URL construction:**
```
{protocol}://{domain}:{port}
```

If port is empty, omit it (use protocol default).

### 2.7 Arguments (User Defined Variables)

Global variables accessible throughout the test:

```xml
<Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
  <collectionProp name="Arguments.arguments">
    <elementProp name="api_key" elementType="Argument">
      <stringProp name="Argument.name">api_key</stringProp>
      <stringProp name="Argument.value">special-key</stringProp>
      <stringProp name="Argument.metadata">=</stringProp>
    </elementProp>
    <elementProp name="pet_name" elementType="Argument">
      <stringProp name="Argument.name">pet_name</stringProp>
      <stringProp name="Argument.value">TestDog</stringProp>
      <stringProp name="Argument.metadata">=</stringProp>
    </elementProp>
  </collectionProp>
</Arguments>
```

**Extraction:**
- `Argument.name` -> variable name
- `Argument.value` -> variable value

### 2.8 ThreadGroup

Defines load profile:

```xml
<ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Users" enabled="true">
  <stringProp name="ThreadGroup.num_threads">10</stringProp>
  <stringProp name="ThreadGroup.ramp_time">5</stringProp>
  <boolProp name="ThreadGroup.scheduler">true</boolProp>
  <stringProp name="ThreadGroup.duration">60</stringProp>
  <stringProp name="ThreadGroup.delay">0</stringProp>
  <elementProp name="ThreadGroup.main_controller" elementType="LoopController">
    <stringProp name="LoopController.loops">1</stringProp>
    <boolProp name="LoopController.continue_forever">false</boolProp>
  </elementProp>
</ThreadGroup>
```

**Properties to extract:**
| Property | pt_scenario Field |
|----------|-------------------|
| `ThreadGroup.num_threads` | `settings.threads` |
| `ThreadGroup.ramp_time` | `settings.rampup` |
| `ThreadGroup.duration` | `settings.duration` |
| `LoopController.loops` | `settings.loops` |

**Scheduler logic:**
- If `scheduler=true` and `duration` set -> use duration
- If `LoopController.loops=-1` -> infinite iterations
- If `LoopController.loops=N` (N>0) -> fixed iterations

### 2.9 HTTPSamplerProxy (HTTP Request)

HTTP request configuration:

```xml
<HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="POST /users" enabled="true">
  <stringProp name="HTTPSampler.domain"></stringProp>
  <stringProp name="HTTPSampler.port"></stringProp>
  <stringProp name="HTTPSampler.protocol"></stringProp>
  <stringProp name="HTTPSampler.path">/api/users</stringProp>
  <stringProp name="HTTPSampler.method">POST</stringProp>
  <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
  <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
  <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
  <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
    <collectionProp name="Arguments.arguments">
      <elementProp name="" elementType="HTTPArgument">
        <stringProp name="Argument.value">{"name": "test"}</stringProp>
      </elementProp>
    </collectionProp>
  </elementProp>
</HTTPSamplerProxy>
```

**Properties to extract:**
| Property | pt_scenario Field | Notes |
|----------|-------------------|-------|
| `testname` | `step.name` | Display name |
| `HTTPSampler.method` | `step.endpoint` (method part) | HTTP method |
| `HTTPSampler.path` | `step.endpoint` (path part) | Request path |
| `HTTPSampler.domain/port/protocol` | Use if not empty | Override defaults |
| `enabled` | `step.enabled` | Enable/disable |
| `HTTPsampler.Arguments` | See below | Body or params |

**Request body extraction:**
- When `HTTPSampler.postBodyRaw=true`: Body is in `Argument.value`
- When `HTTPSampler.postBodyRaw=false`: Arguments are query/form parameters

**Body parsing:**
```python
body_text = argument_value  # e.g., '{"name": "test"}'
try:
    payload = json.loads(body_text)
except:
    payload = body_text  # Keep as raw string
```

**Query parameters extraction:**
When `postBodyRaw=false`, iterate `HTTPsampler.Arguments`:
```python
for arg in arguments:
    name = arg.find("Argument.name").text
    value = arg.find("Argument.value").text
    params[name] = value
```

**Variable references:**
Path may contain variable references like `${petId}` or `$${petId}` (escaped):
- `${petId}` -> keep as is
- `$${petId}` -> unescape to `${petId}`

### 2.10 JSONPostProcessor (Variable Extraction)

Extracts variables from JSON response:

```xml
<JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Extract petId" enabled="true">
  <stringProp name="JSONPostProcessor.referenceNames">petId</stringProp>
  <stringProp name="JSONPostProcessor.jsonPathExprs">$.id</stringProp>
  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
  <stringProp name="JSONPostProcessor.defaultValues">NOT_FOUND</stringProp>
</JSONPostProcessor>
```

**Properties to extract:**
| Property | Description |
|----------|-------------|
| `referenceNames` | Variable name to store result |
| `jsonPathExprs` | JSONPath expression |
| `match_numbers` | "1" = first, "-1" = all, "0" = random |

**Conversion to pt_scenario capture:**
```yaml
capture:
  - petId:
      path: "$.id"
      match: "first"  # if match_numbers=1
```

**Multiple captures:**
If `referenceNames` contains comma-separated values (e.g., `id,name`), split and create multiple captures.

### 2.11 HeaderManager

HTTP headers for requests:

```xml
<HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
  <collectionProp name="HeaderManager.headers">
    <elementProp name="" elementType="Header">
      <stringProp name="Header.name">api_key</stringProp>
      <stringProp name="Header.value">${api_key}</stringProp>
    </elementProp>
    <elementProp name="" elementType="Header">
      <stringProp name="Header.name">Content-Type</stringProp>
      <stringProp name="Header.value">application/json</stringProp>
    </elementProp>
  </collectionProp>
</HeaderManager>
```

**Extraction:**
```yaml
headers:
  api_key: "${api_key}"
  Content-Type: "application/json"
```

### 2.12 ResponseAssertion

Validates HTTP response:

```xml
<ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Assert 200" enabled="true">
  <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
  <intProp name="Assertion.test_type">8</intProp>
  <collectionProp name="Asserion.test_strings">
    <stringProp name="49586">200</stringProp>
  </collectionProp>
</ResponseAssertion>
```

**Note:** `Asserion.test_strings` is a typo in JMeter (missing 't').

**test_field values:**
| Value | Description |
|-------|-------------|
| `Assertion.response_code` | HTTP status code |
| `Assertion.response_data` | Response body |
| `Assertion.response_headers` | Response headers |

**test_type values:**
| Value | Meaning |
|-------|---------|
| 1 | Contains |
| 2 | Matches (regex) |
| 8 | Equals |
| 16 | Substring |

**Conversion:**
- If `test_field=Assertion.response_code` and `test_type=8`:
  - Extract first string from `test_strings` -> `assert.status`

### 2.13 JSONPathAssertion

Validates JSON response fields:

```xml
<JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="Assert name" enabled="true">
  <stringProp name="JSON_PATH">$.name</stringProp>
  <stringProp name="EXPECTED_VALUE">TestDog</stringProp>
  <boolProp name="JSONVALIDATION">true</boolProp>
  <boolProp name="EXPECT_NULL">false</boolProp>
  <boolProp name="INVERT">false</boolProp>
</JSONPathAssertion>
```

**Conversion:**
```yaml
assert:
  body:
    name: "TestDog"  # Simplified from JSONPath $.name
```

### 2.14 ConstantTimer

Fixed delay between requests:

```xml
<ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Think Time" enabled="true">
  <stringProp name="ConstantTimer.delay">1000</stringProp>
</ConstantTimer>
```

**Conversion:**
- If timer is child of sampler -> `step.think_time: 1000`
- If timer is standalone -> create think_time step

### 2.15 UniformRandomTimer

Variable delay:

```xml
<UniformRandomTimer guiclass="UniformRandomTimerGui" testclass="UniformRandomTimer" testname="Random Timer" enabled="true">
  <stringProp name="RandomTimer.range">1000</stringProp>
  <stringProp name="ConstantTimer.delay">500</stringProp>
</UniformRandomTimer>
```

**Calculation:**
- `delay = ConstantTimer.delay + (RandomTimer.range / 2)`
- This gives the average delay

### 2.16 LoopController

Fixed count loops:

```xml
<LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop 5 times" enabled="true">
  <stringProp name="LoopController.loops">5</stringProp>
  <boolProp name="LoopController.continue_forever">false</boolProp>
</LoopController>
```

**Conversion:**
```yaml
loop:
  count: 5
```

### 2.17 WhileController

Condition-based loops:

```xml
<WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="Poll until done" enabled="true">
  <stringProp name="WhileController.condition">${__groovy(vars.get('status') != 'completed')}</stringProp>
</WhileController>
```

**Groovy condition patterns:**
```
${__groovy(vars.get('status') != 'completed')}
${__groovy(vars.get('status') != 'done' && vars.getIteration() <= 100)}
${status} != 'finished'
${__javaScript("${count}" < "10")}
```

**Conversion to JSONPath:**
- `vars.get('varName')` -> `$.varName`
- `!= 'value'` -> `!= 'value'`
- Iteration limit -> `max` field

---

## 3. pt_scenario.yaml Format Reference

### 3.1 Complete Structure

```yaml
name: "Scenario Name"           # Required
description: "Description"      # Optional

settings:                       # Optional
  threads: 10
  rampup: 5
  loops: 1
  duration: 60
  base_url: "http://localhost:8080"

variables:                      # Optional
  api_key: "secret"
  user_name: "test"

scenario:                       # Required
  - name: "Step 1"
    endpoint: "POST /users"
    enabled: true
    headers:
      Content-Type: "application/json"
    params:
      filter: "active"
    payload:
      name: "Test"
    capture:
      - userId
      - token:
          path: "$.auth.token"
          match: "first"
    assert:
      status: 201
      body:
        name: "Test"
    loop:
      count: 5
      interval: 1000
    think_time: 500
```

### 3.2 Settings Object

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `threads` | int | 1 | Concurrent users |
| `rampup` | int | 0 | Ramp-up seconds |
| `loops` | int | null | Iterations (null=1, 0/-1=infinite) |
| `duration` | int | null | Test duration seconds |
| `base_url` | string | null | Override base URL |

### 3.3 Step Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Display name |
| `endpoint` | string | Yes | "METHOD /path" format |
| `enabled` | bool | No | Default: true |
| `headers` | object | No | HTTP headers |
| `params` | object | No | Query parameters |
| `payload` | object | No | Request body (JSON) |
| `capture` | array | No | Variables to extract |
| `assert` | object | No | Response assertions |
| `loop` | object | No | Loop configuration |
| `think_time` | int | No | Delay in milliseconds |

### 3.4 Capture Syntax

Three syntaxes supported:

**Simple (auto-detect):**
```yaml
capture:
  - userId
  - email
```

**Mapped (different field name):**
```yaml
capture:
  - userId: "id"
  - userName: "user.name"
```

**Explicit JSONPath:**
```yaml
capture:
  - userId:
      path: "$.id"
      match: "first"
  - allIds:
      path: "$.items[*].id"
      match: "all"
```

### 3.5 Assert Syntax

```yaml
assert:
  status: 200
  body:
    fieldName: "expectedValue"
  headers:
    Content-Type: "application/json"
```

### 3.6 Loop Syntax

**Fixed count:**
```yaml
loop:
  count: 5
  interval: 1000
```

**While condition:**
```yaml
loop:
  while: "$.status != 'completed'"
  max: 100
  interval: 2000
```

### 3.7 Think Time

Standalone step:
```yaml
- think_time: 1000
```

Or with name:
```yaml
- name: "User thinks"
  think_time: 5000
```

---

## 4. Mapping Table

### 4.1 Complete Element Mapping

| JMX Element | JMX Property | pt_scenario Field | Notes |
|-------------|--------------|-------------------|-------|
| TestPlan | @testname | `name` | Scenario name |
| Arguments | collectionProp | `variables` | Global variables |
| ConfigTestElement | domain/port/protocol | `settings.base_url` | Construct URL |
| ThreadGroup | num_threads | `settings.threads` | |
| ThreadGroup | ramp_time | `settings.rampup` | |
| ThreadGroup | duration | `settings.duration` | If scheduler=true |
| ThreadGroup.main_controller | LoopController.loops | `settings.loops` | |
| HTTPSamplerProxy | @testname | `step.name` | |
| HTTPSamplerProxy | @enabled | `step.enabled` | |
| HTTPSamplerProxy | method + path | `step.endpoint` | "METHOD /path" |
| HTTPSamplerProxy | Arguments (body) | `step.payload` | If postBodyRaw=true |
| HTTPSamplerProxy | Arguments (params) | `step.params` | If postBodyRaw=false |
| JSONPostProcessor | referenceNames | `step.capture[].variable_name` | |
| JSONPostProcessor | jsonPathExprs | `step.capture[].path` | |
| JSONPostProcessor | match_numbers | `step.capture[].match` | 1=first, -1=all |
| HeaderManager | HeaderManager.headers | `step.headers` | |
| ResponseAssertion | test_strings (status) | `step.assert.status` | If test_field=response_code |
| JSONPathAssertion | JSON_PATH + EXPECTED_VALUE | `step.assert.body` | |
| ConstantTimer | delay | `step.think_time` | |
| UniformRandomTimer | range + delay | `step.think_time` | Average delay |
| LoopController | loops | `step.loop.count` | |
| WhileController | condition | `step.loop.while` | Convert Groovy |

### 4.2 Match Number Mapping

| JMX match_numbers | pt_scenario match |
|-------------------|-------------------|
| "1" | "first" |
| "-1" | "all" |
| "0" | "random" (use "first") |
| "N" (N>1) | "first" (warn: N-th not supported) |

---

## 5. Parsing Algorithms

### 5.1 HashTree Hierarchy Algorithm

```python
def build_hash_tree_map(root: ET.Element) -> dict[ET.Element, list[ET.Element]]:
    """
    Build parent-child map from JMX hashTree structure.

    JMX pattern:
    <Element1>
    <hashTree>         <- Children of Element1
      <Element2>
      <hashTree>       <- Children of Element2
      </hashTree>
    </hashTree>

    Returns:
        Dict mapping each element to its child elements
    """
    element_children: dict[ET.Element, list[ET.Element]] = {}

    def process_hash_tree(tree: ET.Element):
        children = list(tree)
        i = 0
        while i < len(children):
            child = children[i]
            if child.tag != 'hashTree':
                # This element's children are in the next hashTree
                element_children[child] = []
                if i + 1 < len(children) and children[i + 1].tag == 'hashTree':
                    child_tree = children[i + 1]
                    # Add direct children (non-hashTree elements)
                    for grandchild in child_tree:
                        if grandchild.tag != 'hashTree':
                            element_children[child].append(grandchild)
                    # Recursively process
                    process_hash_tree(child_tree)
                i += 2  # Skip element and its hashTree
            else:
                i += 1

    # Start from root's main hashTree
    main_tree = root.find('hashTree')
    if main_tree is not None:
        process_hash_tree(main_tree)

    return element_children
```

### 5.2 HTTP Defaults Inheritance

```python
def resolve_sampler_url(
    sampler: ET.Element,
    defaults: JMXDefaults
) -> tuple[str, str, str]:
    """
    Resolve domain, port, protocol for sampler.
    Empty values inherit from HTTP Request Defaults.

    Returns:
        (domain, port, protocol)
    """
    domain = get_string_prop(sampler, "HTTPSampler.domain") or defaults.domain
    port = get_string_prop(sampler, "HTTPSampler.port") or defaults.port
    protocol = get_string_prop(sampler, "HTTPSampler.protocol") or defaults.protocol

    return domain, port, protocol

def build_base_url(domain: str, port: str, protocol: str) -> str:
    """Build base URL from components."""
    if not domain:
        return ""

    protocol = protocol or "http"

    # Default ports can be omitted
    if port and port not in ("80", "443"):
        return f"{protocol}://{domain}:{port}"
    elif port == "443" and protocol == "https":
        return f"https://{domain}"
    elif port == "80" and protocol == "http":
        return f"http://{domain}"
    else:
        return f"{protocol}://{domain}"
```

### 5.3 Groovy to JSONPath Conversion

```python
import re

def convert_groovy_to_jsonpath(groovy_expr: str) -> tuple[str, list[str]]:
    """
    Convert Groovy/JavaScript condition to JSONPath format.

    Args:
        groovy_expr: Groovy expression string

    Returns:
        (jsonpath_condition, warnings)
    """
    warnings = []

    # Pattern 1: ${__groovy(vars.get('varName') != 'value')}
    match = re.search(
        r"\$\{__groovy\(vars\.get\(['\"](\w+)['\"]\)\s*(!=|==)\s*['\"]([^'\"]+)['\"]\)\}",
        groovy_expr
    )
    if match:
        var_name, operator, value = match.groups()
        return f"$.{var_name} {operator} '{value}'", warnings

    # Pattern 2: vars.get('varName') != 'value' (without wrapper)
    match = re.search(
        r"vars\.get\(['\"](\w+)['\"]\)\s*(!=|==)\s*['\"]([^'\"]+)['\"]",
        groovy_expr
    )
    if match:
        var_name, operator, value = match.groups()
        return f"$.{var_name} {operator} '{value}'", warnings

    # Pattern 3: ${varName} != 'value'
    match = re.search(
        r"\$\{(\w+)\}\s*(!=|==)\s*['\"]([^'\"]+)['\"]",
        groovy_expr
    )
    if match:
        var_name, operator, value = match.groups()
        return f"$.{var_name} {operator} '{value}'", warnings

    # Pattern 4: Extract iteration limit
    iter_match = re.search(r"getIteration\(\)\s*<=?\s*(\d+)", groovy_expr)
    max_iterations = int(iter_match.group(1)) if iter_match else 100

    # Cannot convert - return original with warning
    warnings.append(f"Could not convert Groovy expression: {groovy_expr}")
    return groovy_expr, warnings
```

### 5.4 Request Body Extraction

```python
import json

def extract_request_body(sampler: ET.Element) -> tuple[dict | str | None, dict]:
    """
    Extract request body or parameters from HTTPSamplerProxy.

    Returns:
        (payload, params) - One will be populated, other empty/None
    """
    is_raw_body = get_bool_prop(sampler, "HTTPSampler.postBodyRaw", False)

    arguments = sampler.find(".//elementProp[@name='HTTPsampler.Arguments']")
    if arguments is None:
        return None, {}

    collection = arguments.find("collectionProp[@name='Arguments.arguments']")
    if collection is None:
        return None, {}

    if is_raw_body:
        # Raw body mode - single argument with body content
        for arg in collection.findall("elementProp"):
            value = get_string_prop(arg, "Argument.value")
            if value:
                # Try to parse as JSON
                try:
                    return json.loads(value), {}
                except json.JSONDecodeError:
                    return value, {}  # Keep as raw string
        return None, {}
    else:
        # Form parameters mode
        params = {}
        for arg in collection.findall("elementProp"):
            name = get_string_prop(arg, "Argument.name")
            value = get_string_prop(arg, "Argument.value")
            if name:
                params[name] = value
        return None, params
```

### 5.5 Variable Reference Normalization

```python
def normalize_variable_refs(text: str) -> str:
    """
    Normalize variable references in text.

    JMX uses $${varName} to escape ${varName} in some contexts.
    pt_scenario uses ${varName}.

    Args:
        text: Text potentially containing variable references

    Returns:
        Normalized text with ${varName} format
    """
    if not text:
        return text

    # Replace escaped $${var} with ${var}
    return text.replace("$${", "${")
```

---

## 6. Data Structures

### 6.1 Internal Representations

```python
from dataclasses import dataclass, field
from typing import Any, Optional

@dataclass
class JMXDefaults:
    """HTTP Request Defaults extracted from JMX."""
    domain: str = ""
    port: str = ""
    protocol: str = "http"
    content_encoding: str = "UTF-8"


@dataclass
class CaptureConfig:
    """Variable capture configuration."""
    variable_name: str
    jsonpath: str
    match: str = "first"  # "first", "all"


@dataclass
class AssertConfig:
    """Assertion configuration."""
    status: Optional[int] = None
    body: dict[str, Any] = field(default_factory=dict)
    headers: dict[str, str] = field(default_factory=dict)


@dataclass
class LoopConfig:
    """Loop configuration."""
    count: Optional[int] = None
    while_condition: Optional[str] = None
    max_iterations: int = 100
    interval: Optional[int] = None


@dataclass
class ExtractedSampler:
    """Intermediate representation of HTTP sampler."""
    name: str
    method: str
    path: str
    enabled: bool = True
    domain: str = ""
    port: str = ""
    protocol: str = ""
    payload: Optional[dict | str] = None
    params: dict[str, str] = field(default_factory=dict)
    headers: dict[str, str] = field(default_factory=dict)
    captures: list[CaptureConfig] = field(default_factory=list)
    assertions: Optional[AssertConfig] = None
    loop: Optional[LoopConfig] = None
    think_time: Optional[int] = None


@dataclass
class ScenarioSettings:
    """Test execution settings."""
    threads: int = 1
    rampup: int = 0
    loops: Optional[int] = None
    duration: Optional[int] = None
    base_url: Optional[str] = None


@dataclass
class ScenarioStep:
    """A step in the scenario."""
    name: str
    endpoint: str  # "METHOD /path" format
    enabled: bool = True
    headers: dict[str, str] = field(default_factory=dict)
    params: dict[str, Any] = field(default_factory=dict)
    payload: Optional[dict[str, Any]] = None
    capture: list[dict] = field(default_factory=list)  # YAML capture format
    assert_config: Optional[dict] = None  # YAML assert format
    loop: Optional[dict] = None  # YAML loop format
    think_time: Optional[int] = None


@dataclass
class ParsedScenario:
    """Complete parsed scenario."""
    name: str
    description: Optional[str]
    settings: ScenarioSettings
    variables: dict[str, str]
    steps: list[ScenarioStep]


@dataclass
class ImportResult:
    """Result of JMX import operation."""
    success: bool
    scenario: Optional[ParsedScenario] = None
    yaml_path: Optional[str] = None
    warnings: list[str] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)
```

---

## 7. Implementation Guide

### 7.1 Class Structure

```python
class JMXToScenarioConverter:
    """Convert JMeter JMX files to pt_scenario.yaml format."""

    def __init__(self) -> None:
        self._root: Optional[ET.Element] = None
        self._defaults: JMXDefaults = JMXDefaults()
        self._element_children: dict[ET.Element, list[ET.Element]] = {}
        self._warnings: list[str] = []
        self._errors: list[str] = []

    # Main API
    def convert(self, jmx_path: str, output_path: Optional[str] = None) -> ImportResult:
        """Convert JMX file to pt_scenario.yaml."""
        pass

    # Parsing methods
    def _parse_jmx(self, jmx_path: str) -> ET.Element:
        """Parse JMX XML file."""
        pass

    def _build_hash_tree_map(self) -> None:
        """Build element-children map from hashTree structure."""
        pass

    # Extraction methods
    def _extract_test_plan_name(self) -> str:
        """Extract scenario name from TestPlan."""
        pass

    def _extract_http_defaults(self) -> JMXDefaults:
        """Extract HTTP Request Defaults."""
        pass

    def _extract_user_variables(self) -> dict[str, str]:
        """Extract User Defined Variables."""
        pass

    def _extract_thread_settings(self) -> ScenarioSettings:
        """Extract ThreadGroup settings."""
        pass

    def _extract_samplers(self) -> list[ExtractedSampler]:
        """Extract all HTTP samplers in order."""
        pass

    def _extract_sampler_data(
        self,
        sampler: ET.Element,
        children: list[ET.Element]
    ) -> ExtractedSampler:
        """Extract data from single HTTPSamplerProxy."""
        pass

    def _extract_captures(self, children: list[ET.Element]) -> list[CaptureConfig]:
        """Extract JSONPostProcessor as captures."""
        pass

    def _extract_headers(self, children: list[ET.Element]) -> dict[str, str]:
        """Extract HeaderManager headers."""
        pass

    def _extract_assertions(self, children: list[ET.Element]) -> Optional[AssertConfig]:
        """Extract assertions."""
        pass

    def _extract_timers(self, children: list[ET.Element]) -> Optional[int]:
        """Extract timer as think_time."""
        pass

    def _extract_loop(self, element: ET.Element) -> Optional[LoopConfig]:
        """Extract loop controller configuration."""
        pass

    # Conversion methods
    def _convert_groovy_condition(self, condition: str) -> str:
        """Convert Groovy to JSONPath condition."""
        pass

    def _sampler_to_step(self, sampler: ExtractedSampler) -> ScenarioStep:
        """Convert ExtractedSampler to ScenarioStep."""
        pass

    def _capture_to_yaml(self, capture: CaptureConfig) -> dict | str:
        """Convert CaptureConfig to YAML capture format."""
        pass

    # Output methods
    def _build_scenario(self, samplers: list[ExtractedSampler]) -> ParsedScenario:
        """Build ParsedScenario from extracted data."""
        pass

    def _generate_yaml(self, scenario: ParsedScenario, output_path: str) -> None:
        """Write scenario to YAML file."""
        pass
```

### 7.2 Implementation Order

1. **XML Parsing Foundation**
   - `_parse_jmx()` - Load and validate XML
   - `_build_hash_tree_map()` - Build element hierarchy

2. **Global Configuration**
   - `_extract_test_plan_name()`
   - `_extract_http_defaults()`
   - `_extract_user_variables()`
   - `_extract_thread_settings()`

3. **HTTP Sampler Extraction**
   - `_extract_samplers()` - Find all samplers in order
   - `_extract_sampler_data()` - Extract method, path, body, params

4. **Sampler Children**
   - `_extract_captures()` - JSONPostProcessor
   - `_extract_headers()` - HeaderManager
   - `_extract_assertions()` - ResponseAssertion, JSONPathAssertion
   - `_extract_timers()` - ConstantTimer, UniformRandomTimer

5. **Controllers** (optional)
   - `_extract_loop()` - LoopController, WhileController
   - `_convert_groovy_condition()` - Groovy to JSONPath

6. **Conversion**
   - `_sampler_to_step()` - Create ScenarioStep
   - `_capture_to_yaml()` - Format captures
   - `_build_scenario()` - Assemble ParsedScenario

7. **Output**
   - `_generate_yaml()` - Write YAML file
   - `convert()` - Main orchestration

### 7.3 Helper Functions

```python
def get_string_prop(element: ET.Element, name: str, default: str = "") -> str:
    """Get stringProp value by name."""
    prop = element.find(f"stringProp[@name='{name}']")
    return prop.text if prop is not None and prop.text else default


def get_bool_prop(element: ET.Element, name: str, default: bool = False) -> bool:
    """Get boolProp value by name."""
    prop = element.find(f"boolProp[@name='{name}']")
    if prop is not None and prop.text:
        return prop.text.lower() == "true"
    return default


def get_int_prop(element: ET.Element, name: str, default: int = 0) -> int:
    """Get intProp or stringProp as int."""
    # Try intProp first
    prop = element.find(f"intProp[@name='{name}']")
    if prop is not None and prop.text:
        return int(prop.text)
    # Try stringProp (JMeter sometimes uses string for numbers)
    prop = element.find(f"stringProp[@name='{name}']")
    if prop is not None and prop.text:
        try:
            return int(prop.text)
        except ValueError:
            pass
    return default
```

---

## 8. Edge Cases and Limitations

### 8.1 Supported JMX Elements

| Element | Support Level |
|---------|---------------|
| TestPlan | Full |
| ThreadGroup | Full |
| HTTPSamplerProxy | Full |
| ConfigTestElement (HTTP Defaults) | Full |
| Arguments (User Variables) | Full |
| JSONPostProcessor | Full |
| HeaderManager | Full |
| ResponseAssertion | Partial (status code only) |
| JSONPathAssertion | Full |
| ConstantTimer | Full |
| UniformRandomTimer | Partial (average delay) |
| LoopController | Full |
| WhileController | Partial (simple conditions) |
| TransactionController | Ignored (flattened) |

### 8.2 Unsupported Elements (Skip with Warning)

| Element | Reason |
|---------|--------|
| RegexExtractor | Regex not in pt_scenario spec |
| BeanShellPostProcessor | Script not portable |
| JSR223PostProcessor | Script not portable |
| CSVDataSetConfig | External data source not in spec |
| IfController | Conditional logic not in spec |
| ResultCollector | Listener, not relevant |
| Custom samplers | Non-HTTP not supported |

### 8.3 Conversion Limitations

1. **Complex Groovy expressions**: Only simple `vars.get('x') != 'y'` patterns convert. Complex logic generates warning.

2. **Multiple ThreadGroups**: Only first ThreadGroup converted. Others generate warning.

3. **Nested controllers**: Controllers within controllers flatten to sequential steps.

4. **Transaction controllers**: Ignored, samplers extracted directly.

5. **Multiple assertions**: Merged into single `assert` object.

6. **N-th match extraction**: `match_numbers > 1` converts to `first` with warning.

7. **Response data assertions**: Body contains/matches not fully supported.

8. **Variable scope**: All captures become global (no step-level scope).

---

## 9. Test Cases

### 9.1 Basic Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Empty JMX | Minimal valid JMX | Empty scenario with defaults |
| TestPlan name | JMX with custom testname | `name:` matches testname |
| HTTP Defaults | JMX with ConfigTestElement | `settings.base_url` populated |
| User variables | JMX with Arguments | `variables:` section populated |
| Thread settings | JMX with ThreadGroup | `settings:` section populated |

### 9.2 Sampler Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| GET request | Simple GET sampler | `endpoint: "GET /path"` |
| POST with body | POST with JSON body | `endpoint` + `payload` |
| Query params | GET with params | `endpoint` + `params` |
| Path variables | Path with `${var}` | Variables preserved |
| Disabled sampler | `enabled="false"` | `enabled: false` |
| Multiple samplers | 5 samplers | 5 steps in order |

### 9.3 Capture Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Single capture | One JSONPostProcessor | One capture item |
| Multiple captures | Multiple processors | Multiple capture items |
| Match first | `match_numbers=1` | `match: "first"` |
| Match all | `match_numbers=-1` | `match: "all"` |

### 9.4 Timer Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Constant timer | `delay=1000` | `think_time: 1000` |
| Random timer | `range=1000, delay=500` | `think_time: 1000` (avg) |

### 9.5 Assertion Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Status 200 | ResponseAssertion | `assert.status: 200` |
| Status 201 | ResponseAssertion | `assert.status: 201` |
| JSON assertion | JSONPathAssertion | `assert.body.field: value` |

### 9.6 Loop Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Fixed count | LoopController(5) | `loop.count: 5` |
| While condition | WhileController | `loop.while: ...` |

### 9.7 Header Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Single header | One Header element | `headers:` with one entry |
| Multiple headers | Multiple Headers | `headers:` with all entries |
| Variable header | `${token}` value | Variable preserved |

### 9.8 Integration Tests

| Test | Input | Expected Output |
|------|-------|-----------------|
| Petstore CRUD | Real petstore JMX | Valid scenario YAML |
| Complex flow | JMX with all elements | Complete scenario |
| Roundtrip | scenario -> JMX -> scenario | Equivalent YAML |

---

## 10. Example Conversions

### 10.1 Simple GET Request

**JMX Input:**
```xml
<HTTPSamplerProxy testname="Get Users" enabled="true">
  <stringProp name="HTTPSampler.method">GET</stringProp>
  <stringProp name="HTTPSampler.path">/api/users</stringProp>
</HTTPSamplerProxy>
```

**YAML Output:**
```yaml
- name: "Get Users"
  endpoint: "GET /api/users"
  enabled: true
```

### 10.2 POST with JSON Body

**JMX Input:**
```xml
<HTTPSamplerProxy testname="Create User" enabled="true">
  <stringProp name="HTTPSampler.method">POST</stringProp>
  <stringProp name="HTTPSampler.path">/api/users</stringProp>
  <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
  <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
    <collectionProp name="Arguments.arguments">
      <elementProp name="" elementType="HTTPArgument">
        <stringProp name="Argument.value">{"name": "Test", "email": "test@example.com"}</stringProp>
      </elementProp>
    </collectionProp>
  </elementProp>
</HTTPSamplerProxy>
```

**YAML Output:**
```yaml
- name: "Create User"
  endpoint: "POST /api/users"
  payload:
    name: "Test"
    email: "test@example.com"
```

### 10.3 Request with Capture

**JMX Input:**
```xml
<HTTPSamplerProxy testname="Create Pet">...</HTTPSamplerProxy>
<hashTree>
  <JSONPostProcessor testname="Extract petId" enabled="true">
    <stringProp name="JSONPostProcessor.referenceNames">petId</stringProp>
    <stringProp name="JSONPostProcessor.jsonPathExprs">$.id</stringProp>
    <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
  </JSONPostProcessor>
</hashTree>
```

**YAML Output:**
```yaml
- name: "Create Pet"
  endpoint: "POST /pet"
  capture:
    - petId:
        path: "$.id"
        match: "first"
```

### 10.4 Request with Headers and Assertion

**JMX Input:**
```xml
<HTTPSamplerProxy testname="Get Pet">...</HTTPSamplerProxy>
<hashTree>
  <HeaderManager>
    <collectionProp name="HeaderManager.headers">
      <elementProp elementType="Header">
        <stringProp name="Header.name">api_key</stringProp>
        <stringProp name="Header.value">${api_key}</stringProp>
      </elementProp>
    </collectionProp>
  </HeaderManager>
  <ResponseAssertion>
    <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
    <intProp name="Assertion.test_type">8</intProp>
    <collectionProp name="Asserion.test_strings">
      <stringProp>200</stringProp>
    </collectionProp>
  </ResponseAssertion>
</hashTree>
```

**YAML Output:**
```yaml
- name: "Get Pet"
  endpoint: "GET /pet/${petId}"
  headers:
    api_key: "${api_key}"
  assert:
    status: 200
```

### 10.5 Complete Flow (Petstore CRUD)

**JMX Input:** See section 2.9 example

**YAML Output:**
```yaml
name: "Petstore CRUD Flow v1.0"

settings:
  threads: 1
  rampup: 0
  loops: 1
  base_url: "https://petstore.swagger.io"

variables:
  api_key: "special-key"
  pet_name: "TestDog"
  pet_status: "available"

scenario:
  - name: "[1] Add a new pet"
    endpoint: "POST /pet"
    payload:
      id: 12345
      name: "${pet_name}"
      status: "${pet_status}"
      category:
        id: 1
        name: "Dogs"
      photoUrls:
        - "https://example.com/photo.jpg"
      tags:
        - id: 1
          name: "tag1"
    capture:
      - petId:
          path: "$.id"
          match: "first"
    assert:
      status: 200

  - name: "[2] Get pet by ID"
    endpoint: "GET /pet/${petId}"
    headers:
      api_key: "${api_key}"
    assert:
      status: 200
      body:
        name: "${pet_name}"

  - name: "[3] Update pet"
    endpoint: "PUT /pet"
    payload:
      id: "${petId}"
      name: "${pet_name}-updated"
      status: "sold"
    assert:
      status: 200

  - name: "[4] Find pets by status"
    endpoint: "GET /pet/findByStatus"
    params:
      status: "sold"
    assert:
      status: 200

  - name: "[5] Delete pet"
    endpoint: "DELETE /pet/${petId}"
    headers:
      api_key: "${api_key}"
    assert:
      status: 200
```

---

## 11. CLI Interface (Recommended)

### 11.1 Command Structure

```bash
jmx-to-scenario <input.jmx> [--output <output.yaml>] [--verbose]
```

### 11.2 Arguments

| Argument | Required | Default | Description |
|----------|----------|---------|-------------|
| `input.jmx` | Yes | - | Path to JMX file |
| `--output` | No | `pt_scenario.yaml` | Output YAML path |
| `--verbose` | No | False | Show detailed output |

### 11.3 Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | Parse error (invalid JMX) |
| 2 | Conversion error |
| 3 | File I/O error |

### 11.4 Output Example

```
JMX to pt_scenario.yaml Converter

Input:  petstore-crud-flow-test.jmx
Output: pt_scenario.yaml

Extracted:
  - Scenario name: Petstore CRUD Flow v1.0
  - Base URL: https://petstore.swagger.io
  - Variables: 3
  - Steps: 5
  - Captures: 1
  - Assertions: 5

Warnings:
  - Line 42: TransactionController ignored (not supported)

Conversion complete!
```

---

## 12. References

- JMeter JMX Wiki: https://cwiki.apache.org/confluence/display/JMETER/JmxTestPlan
- JMeter Component Reference: https://jmeter.apache.org/usermanual/component_reference.html
- pt_scenario.yaml Specification: Original project documentation
- Python xml.etree.ElementTree: https://docs.python.org/3/library/xml.etree.elementtree.html
- PyYAML: https://pyyaml.org/wiki/PyYAMLDocumentation
